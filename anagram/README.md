# Определить, являются ли две строки анаграммами

_Задание на собеседовании в компанию [IT_ONE](https://www.it-one.ru/) 08.02.2022_

### Задача

Реализовать метод, который на вход принимает две строки и проверяет, являются ли они анаграммами.

### Решение

* 1 вариант - проверка с помощью сортировки (_isAnagramSort_)
     
Сначала сравниваем длину обеих строк. Если они не равны, то это уже не анаграмма и нужно завершить работу алгоритма.
     
Переставим символы каждой строки, отсортировав их символы, что приведет к созданию двух нормализованных массивов символов.
     
Если две строки являются анаграммами, их нормализованные формы должны быть одинаковыми.
     
В Java можно сначала преобразовать две строки в массивы _char[]_.

Затем отсортировать эти два массива и проверить на равенство.
     
Общее время выполнения этого алгоритма составляет _**O(n log n)**_, поскольку сортировка массива из _n_ символов занимает _O(n log n)_ времени.

Чтобы алгоритм функционировал, он должен скопировать обе входные строки в виде массивов символов, используя немного дополнительной памяти.

* 2 вариант - проверка с помощью сортировки в одну строчку кода (_isAnagramSortMinimum_)

* 3 вариант - проверка путем подсчета (_isAnagramCounting_)

Альтернативная стратегия - подсчитать количество вхождений каждого символа во входные данные.

Если эти гистограммы равны между входными данными, то строки являются анаграммами.

Чтобы сэкономить немного памяти, построим только одну гистограмму.

Увеличим количество для каждого символа в первой строке и уменьшим количество для каждого символа во второй.

Если две строки являются анаграммами, то результатом сравнения будет 0.

Для гистограммы требуется таблица подсчетов фиксированного размера, который определяется размером набора символов.

Например, если используем только один байт для хранения каждого символа, то можно использовать размер массив размером 256 для подсчета вхождения каждого символа.

Это решение быстрее и имеет временную сложность _**O(n)**_. Однако для подсчета требуется дополнительное пространство.

При 256 целых числах для _ASCII_ это не так уж плохо.

Однако, если нужно увеличить _characterRange_ для поддержки многобайтовых наборов символов, таких как _UTF-8_, это приведет к большой нехватке памяти.

Поэтому это решение актуально, только когда количество возможных символов находится в небольшом диапазоне.

С точки зрения разработки это решение содержит больше кода для поддержки и меньше использует функции библиотеки _Java_.

* 4 вариант - проверка с помощью _MultiSet_ (_isAnagramMultiset_)

Можно упростить процесс подсчета и сравнения, используя _MultiSet_.

_MultiSet_ - это коллекция, которая поддерживает не зависящее от порядка равенство с повторяющимися элементами.

Например, мультимножества _{a, a, b}_ и _{a, b, a}_ равны.

Чтобы использовать _Multiset_, сначала нужно добавить зависимость _Guava_ в файл _pom.xml_.

Далее преобразуем каждую из входных строк в мультимножество символов. Затем проверим, равны ли они.

Этот алгоритм решает проблему за _**O(n)**_ без необходимости объявлять большой массив для подсчета.

Он похож на предыдущее решение для подсчета. Однако вместо использования таблицы фиксированного размера для подсчета
можно использовать класс _MutlitSet_ для имитации таблицы переменного размера с подсчетом для каждого символа.

* 5 вариант - анаграмма на основе букв (_isLetterBasedAnagramMultiset_)

Приведенные до сих пор примеры не соответствуют строго лингвистическому определению анаграммы.

Это потому, что они считают знаки препинания частью анаграммы, и они чувствительны к регистру.

Адаптируем алгоритмы, чтобы включить анаграмму на основе букв.

Рассмотрим только перестановку букв без учета регистра, независимо от других символов, таких как пробелы и знаки препинания.

Например, "_A decimal point._" и “_I’m a dot in place._” были бы анаграммами друг друга.

Чтобы решить эту проблему, можно сначала предварительно обработать две входные строки, чтобы отфильтровать нежелательные символы и преобразовать буквы в строчные буквы.

Затем можно использовать одно из приведенных выше решений (например, решение с несколькими наборами) для проверки анаграмм в обработанных строках.

[Источник](https://www.baeldung.com/java-strings-anagrams)
# Найти в строке первый уникальный символ

_Задание на собеседовании в компанию [IT_ONE](https://www.it-one.ru/) 29.06.2022_

### Задача

Входная строка может быть любой длины и может содержать сочетание символов верхнего и нижнего регистра.

Решение должно проверять пустой ввод или _null_.

Во входной строке не может быть неповторяющихся символов, или, другими словами, должен быть ввод,
в котором символы повторяются хотя бы один раз, в противном случае вывод будет _null_.

### Пример

| На входе | На выходе |
|---------|-----------|
| abc     | a         |
| abca    | b         |
| abcab   | c         |
| abcabcd | d         |

### Решение

<details>
<summary>
<b>1 вариант - перебором через массив (getFirstUniqueLetter)</b>
</summary>
Временная сложность решения составляет _**O(n²)**_ из-за двух вложенных циклов.
</details>

<details>
<summary>
<b>2 вариант - перебором без массива (firstNonRepeatingCharBruteForceNaive)</b>
</summary>

Начинаем с начала строки, берем по одному символу за раз и сравниваем символ с каждым символом строки.  

Если находим совпадение, то это означает, что данный символ повторяется в другом месте строки, поэтому переходим к следующему символу.

Если нет совпадения для символа, мы нашли решение и выходим из программы с символом.

Временная сложность решения составляет _**O(n²)**_ из-за двух вложенных циклов.

Для каждого символа приходится перебирать все символы входной строки.
</details>

<details>
<summary>
<b>3 вариант (firstNonRepeatingCharBruteForce)</b>
</summary>

Более компактное решение 2 варианта, в котором используются методы _lastIndexOf_ класса _String_.

Если находим символ, чей первый индекс в строке также является последним индексом, то это означает,
что символ существует только по этому индексу в строке и, следовательно, становится первым неповторяющимся символом.

Временная сложность - _**_O(n)_**_.

Метод _lastIndexOf_ выполняется за время **_O(n)_** в дополнение к уже запущенному внешнему циклу,
что делает это решение в итоге **_O(n²)_**, аналогично предыдущему.
</details>

<details>
<summary>
<b>4 вариант - оптимизированный через Map (firstNonRepeatingCharWithMap)</b>
</summary>

Узким местом предыдущих решений является то, что приходится сравнивать каждый символ со всеми символами в строке,
пока не достигнем конца строки или не найдем ответ.

Но если запомнить, сколько раз появляется каждый символ, то не нужно будет сравнивать каждый раз.

Вместо этого нужно просто искать частоту появления символа.

Для этой цели можно использовать _Map_, точнее, _HashMap_.

_Map_ будет хранить символ в качестве ключа и его частоту в качестве значения.

Когда берем каждый символ, есть два варианта:
- если символ уже есть в _Map_, то добавляем текущую позицию к его значению;
- если символа еще нет в _Map_, то это новый символ, поэтому увеличиваем значение количества его вхождений в строку.

После завершения вычисления для всей строки будет _Map_, которая покажет количество каждого символа в строке.

Останется только еще раз перебрать _String_ и найти первый символ, у которого значение в _Map_ равно единице. Это и будет ответом.

Решение будет работать намного быстрее, учитывая, что поиск в _Map_ является операцией с постоянным временем **_O(1)_**.

Это означает, что время получения результата не будет расти с увеличением размера входной строки.
</details>

<details>
<summary>
<b>5 вариант - при ограничении входной строки (firstNonRepeatingCharWithArray)</b>
</summary>

Если ограничить набор входных символов только символами нижнего регистра/символами верхнего регистра/символами английского алфавита и т. д., то лучшим решением будет использование массива фиксированного размера.

Например, если ввод ограничен только строчными буквами латинского алфавита без разделителей, можно использовать массив размером 26, где каждый индекс в массиве относится к алфавиту, а значение может обозначать частоту символа в строке.

Первый символ в строке, значение которого в массиве равно 1, является ответом.
</details>

_[Источник](https://www.baeldung.com/java-find-the-first-non-repeating-character)_
